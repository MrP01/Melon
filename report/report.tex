\documentclass{prettytex/ox/mmsc-special-topic}
\input{customisations.tex}
\addbibresource{sources.bib}
\tikzexternalize[prefix=tikz/]

\newcommand{\topictitle}{
  Melon - a Task Scheduling Package for Personal Todo Lists \\
  \normalsize using Markov Chain Monte-Carlo Methods
}
\newcommand{\candidatenumber}{1072462}
\newcommand{\course}{Python in Scientific Computing}

\title{\topictitle}
\author{Candidate \candidatenumber}
\date{\today}

\makenoidxglossaries
\newacronym{ode}{ODE}{Ordinary Differential Equation}
\newacronym{pde}{PDE}{Partial Differential Equation}
\newacronym{gui}{GUI}{Graphical User Interface}

\begin{document}
  \pagestyle{plain}
  \mmscSpecialHeader

  \begin{abstract}
    \label{abstract}
    In this project report we will review the central concepts utilised in the group work conducted to make progress in the \gls{pde} problem associated with the electrochemical model of a battery cell and present numerical results.
    \vspace*{0.2cm}

    \noindent
    \textbf{Our Goal:}
    Numerically obtain the solution $\{a(x, T), b(x, T)\}$.

    The Finite Difference schemes are implemented in Julia and Python, whereas the Spectral Method is implemented in C++.
  \end{abstract}

  \begin{figure}[H]
    \centering
    % \includegraphics[width=\linewidth]{figures/screenshot.png}
    \caption{The \gls{gui} of the Spectral Solver.}
    \label{fig:gui}
  \end{figure}

  \pagebreak
  \pagestyle{normal}

  \section{Problem Introduction}
  \label{sec:introduction}

  UIDs are useful because they make collisions very unlikely, which is not to say that these should not be checked, but if two clients are connected that each generated a set of UIDs it is very unlikely to have to do conflict resolving.

  We recommend usage with \texttt{xandikos}, a version-controlled DAV server, capable of syncing calendars (events, todos and journals) and contacts.

  Published on PyPi.

  \subsection{Usage}
  % TODO: describe installation, etc., running main.py
  Use \texttt{invoke -l} to list all available tasks.

  \texttt{conan install . ----output-folder=build ----build=missing}

  Is platform-independent, for example due to the usage of \texttt{pathlib.Path}.

  \section{Underlying Theory}
  \begin{algorithm}[language=pseudo,caption={\centering The Metropolis-Hastings sub-routine \parencite{metropolis, hastings}},basicstyle=\footnotesize]
until convergence, repeat
  sample a candidate $\vec{x}^*$.
  set $\vec{x}^{n+1} = \vec{x}^*$ with acceptance probability
    $p_{\rm accept} = \min\left(1, \e^{-\beta (F^{n+1} - F^n)}\right)\,,$ with $\beta \in \R^+$ a transition factor.
  Otherwise, let $\vec{x}^{n+1} = \vec{x}^{n}$.
  \end{algorithm}

  Which is a subroutine to an outer iteration, a technique commonly referred to as Simulated Annealing.

  \begin{algorithm}[language=pseudo,caption={\centering Simulated Annealing},basicstyle=\footnotesize]
until convergence, repeat
  \end{algorithm}

  \section{Code Quality}
  \subsection{Formatting}
  \subsection{Docstrings}
  \subsection{Documentation}
  \subsection{Tests}
  Server can be started using Docker.

  As we can see using \texttt{pytest ----durations=0},

  \texttt{
    ========================= slowest durations ========================= \\
    3.53s call TestScheduler::test\_length[NumbaMCMCScheduler] \\
    0.19s call TestMelon::test\_init\_store\_and\_load \\
    (...)
  }

  the slowest test is the Numba scheduler which takes some time to pre-compile the functions.
  So even when the runtime of the Numba scheduler itself is low (cf. \cref{sec:runtime}), the test will always take some time.

  \subsubsection{Coverage}

  (coverage here)

  Which may be reproduced using \texttt{pytest --cov=melon}.

  \subsection{Type Checking}
  Using \texttt{pyright} instead of \texttt{mypy} as it is much faster.
  \subsection{Using Appropriate Language Features}
  Using \texttt{autoflake} and \texttt{pyupgrade}.
  Used \texttt{logging}.
  \subsection{Maintaining Code Quality}
  Using \texttt{pre-commit} and GitHub Actions CI/CD.

  \subsection{Publishing to PyPi}
  Although we believe it would have been possible to compile the C++ and Rust implementations on a CI service using a ``platform matrix'', the published package only contains compilation targets for the x86\_64 platform and Python 3.11.

  \texttt{
    \hspace*{-1em} prettier........................................................\textcolor{green}{Passed} \\
    fix end of files................................................\textcolor{green}{Passed} \\
    trim trailing whitespace........................................\textcolor{green}{Passed} \\
    black...........................................................\textcolor{green}{Passed} \\
    ruff............................................................\textcolor{green}{Passed} \\
    check blanket noqa..............................................\textcolor{green}{Passed} \\
    check for eval()................................................\textcolor{green}{Passed} \\
    interrogate.....................................................\textcolor{green}{Passed} \\
    autoflake.......................................................\textcolor{green}{Passed} \\
    pyupgrade.......................................................\textcolor{green}{Passed} \\
    pyright.........................................................\textcolor{green}{Passed} \\
    pytest-check....................................................\textcolor{green}{Passed} \\
    clang-format....................................................\textcolor{green}{Passed} \\
    latex-format-all................................................\textcolor{green}{Passed}
  }

  Uses \texttt{invoke} to manage common development tasks.

  Also have \texttt{nitpick} to synchronise linter configuration across projects.

  \begin{minted}{python}
    import numpy
    x = 5
    print(x ** 2)
  \end{minted}

  interrogate -v einfügen

  \begin{table}[H]
    \centering
    \caption{RESULT: PASSED (minimum: 80.0\%, actual: 100.0\%)}
    \begin{tabular}{lllll}
      \hline
      \bf Name                        & \bf Total & \bf Miss & \bf Cover & \bf Cover                 \\
      \hline
      main.py                         & 2         & 0        & 2         & \textcolor{green}{100 \%} \\
      tasks.py                        & 8         & 0        & 8         & \textcolor{green}{100 \%} \\
      docs/conf.py                    & 1         & 0        & 1         & \textcolor{green}{100 \%} \\
      melon/\_\_init\_\_.py           & 1         & 0        & 1         & \textcolor{green}{100 \%} \\
      melon/calendar.py               & 11        & 0        & 11        & \textcolor{green}{100 \%} \\
      melon/config.py                 & 1         & 0        & 1         & \textcolor{green}{100 \%} \\
      melon/melon.py                  & 19        & 0        & 19        & \textcolor{green}{100 \%} \\
      melon/todo.py                   & 20        & 0        & 20        & \textcolor{green}{100 \%} \\
      melon/visualise.py              & 3         & 0        & 3         & \textcolor{green}{100 \%} \\
      melon/scheduler/\_\_init\_\_.py & 1         & 0        & 1         & \textcolor{green}{100 \%} \\
      melon/scheduler/base.py         & 10        & 0        & 10        & \textcolor{green}{100 \%} \\
      melon/scheduler/cpp.py          & 3         & 0        & 3         & \textcolor{green}{100 \%} \\
      melon/scheduler/numba.py        & 8         & 0        & 8         & \textcolor{green}{100 \%} \\
      melon/scheduler/purepython.py   & 12        & 0        & 12        & \textcolor{green}{100 \%} \\
      melon/scheduler/rust.py         & 3         & 0        & 3         & \textcolor{green}{100 \%} \\
      melongui/\_\_init\_\_.py        & 1         & 0        & 1         & \textcolor{green}{100 \%} \\
      melongui/calendarlist.py        & 6         & 0        & 6         & \textcolor{green}{100 \%} \\
      melongui/mainwindow.py          & 14        & 0        & 14        & \textcolor{green}{100 \%} \\
      melongui/taskitemdelegate.py    & 12        & 0        & 12        & \textcolor{green}{100 \%} \\
      melongui/tasklist.py            & 14        & 0        & 14        & \textcolor{green}{100 \%} \\
      melongui/taskwidgets.py         & 8         & 0        & 8         & \textcolor{green}{100 \%} \\
      tests/\_\_init\_\_.py           & 1         & 0        & 1         & \textcolor{green}{100 \%} \\
      tests/test\_melon.py            & 7         & 0        & 7         & \textcolor{green}{100 \%} \\
      tests/test\_scheduler.py        & 9         & 0        & 9         & \textcolor{green}{100 \%} \\
      \hline
      \bf TOTAL                       & 175       & 0        & 175       & \textcolor{green}{100 \%} \\
      \hline
    \end{tabular}
  \end{table}

  Screenshot von gnome-calendar

  Screenshot GUI

  \subsection{Autocorrelation Analysis}
  \subsection{Coole Pie-Plots mit Verteilungen}

  \section{Runtime Performance}
  \label{sec:runtime}
  The following benchmarks were all accumulated on an x86\_64 Intel\textregistered \, i7-5600U CPU running at \SI{2.6}{\giga\hertz} verified through 3 individual runs, keeping parameters consistent along them.

  \begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{results/complexity.pdf}
    \caption{Complexity plot}
  \end{figure}

  \begin{minted}{python}
In [1]: %timeit str(t.icalendar_component["uid"])
  122 µs ± 1.06 µs per loop (7 runs, 10,000 loops each)
In [2]: %timeit t.vtodo.contents["uid"][0].value
  355 ns ± 7.14 ns per loop (7 runs, 1,000,000 loops each)
In [3]: %timeit t.vobject_instance.contents["vtodo"][0].contents["uid"][0].value
  296 ns ± 7.06 ns per loop (7 runs, 1,000,000 loops each)
In [4]: %timeit t._vobject_instance.contents["vtodo"][0].contents["uid"][0].value
  208 ns ± 23.7 ns per loop (7 runs, 10,000,000 loops each)
  \end{minted}

  \begin{table}[H]
    \centering
    \caption{Profile obtained by running \mintinline{bash}{./main.py --profile & grep todo.py}.}
    \begin{tabular}{rrrrrll}
      \hline
      ncalls & tottime & percall & cumtime & percall & filename:lineno & function     \\
      \hline
      16958  & 0.008   & 0.000   & 0.939   & 0.000   & todo.py:36      & vtodo        \\
      32475  & 0.047   & 0.000   & 0.705   & 0.000   & todo.py:96      & uid          \\
      856    & 0.003   & 0.000   & 0.579   & 0.001   & todo.py:26      & upgrade      \\
      117    & 0.000   & 0.000   & 0.489   & 0.004   & todo.py:111     & priority     \\
      417    & 0.001   & 0.000   & 0.461   & 0.001   & todo.py:121     & isIncomplete \\
      5512   & 0.003   & 0.000   & 0.278   & 0.000   & todo.py:45      & summary      \\
      856    & 0.002   & 0.000   & 0.112   & 0.000   & todo.py:21      & \_\_init\_\_ \\
      1363   & 0.006   & 0.000   & 0.024   & 0.000   & todo.py:164     & \_\_lt\_\_   \\
      7844   & 0.004   & 0.000   & 0.009   & 0.000   & todo.py:61      & dueDate      \\
      2605   & 0.001   & 0.000   & 0.003   & 0.000   & todo.py:85      & dueTime      \\
    \end{tabular}
  \end{table}

  \begin{table}[H]
    \centering
    \caption{Profile obtained by running \mintinline{bash}{inv profile-scheduler & grep purepython.py}.}
    \begin{tabular}{rrrrrll}
      \hline
      \bf Ncalls & \bf Total & \bf / call & \bf Cum. & \bf / call & \bf Filename:line & \bf Function     \\
      \hline
      1          & 0.000     & 0.000      & 14.236   & 14.236     & purepython:142    & schedule         \\
      10         & 0.209     & 0.021      & 14.235   & 1.424      & purepython:123    & mcmcSweep        \\
      36010      & 1.144     & 0.000      & 13.784   & 0.000      & purepython:97     & computeEnergy    \\
      2196671    & 5.391     & 0.000      & 11.353   & 0.000      & purepython:41     & spreadTasks      \\
      1006332    & 1.389     & 0.000      & 1.842    & 0.000      & purepython:27     & generateNextSlot \\
      2196610    & 0.798     & 0.000      & 0.972    & 0.000      & purepython:108    & <genexpr>        \\
      2196610    & 0.384     & 0.000      & 0.384    & 0.000      & purepython:106    & <genexpr>        \\
      36000      & 0.082     & 0.000      & 0.217    & 0.000      & purepython:83     & permuteState     \\
      36011      & 0.046     & 0.000      & 0.124    & 0.000      & purepython:19     & startingSlot     \\
    \end{tabular}
  \end{table}

  \section{Results}
  \begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{results/convergence.pdf}
    \caption{Convergence}
  \end{figure}

  Numba Compilation time: 2.5625428539933637

  \begin{table}[H]
    \vspace{0.5cm}
    \centering
    \caption{Runtime Comparison of the different implementations run on the same scenarios. Each runtime is given as the average over three runs. The finite difference schemes (for the one-dimensional case) were run with $N_x = N_t = 4000$ up to $T = 40$. The spectral method was run using a series expansion of order 15, also up to $T = 40$. The remaining parameters ($\alpha$, $\kappa_0$, $E_0$, etc.) were all identical.}
    \begin{tblr}{
      colspec={llr},
      row{2,3} = {bg=azure9},
          row{4} = {bg=violet9},
          row{5} = {bg=cyan9},
        }
      \hline
      \bf Implementation & \bf Language & \bf Runtime / seconds \\
      \hline
      MCMCScheduler      & Python & 16.6180 \\
      NumbaMCMCScheduler & Python & 1.3117 \\
      \hline
      RustyMCMCScheduler & Rust & 0.3660 \\
      \hline
      CppMCMCScheduler   & C++ & 0.1513
      \hline
    \end{tblr}
    \label{table:runtime}
  \end{table}

  \section{Acknowledgements}
  The visualisation code (\texttt{visualise.py}) is adapted from \cite{monte-carlo-todo-lists}.

  The task check icon is the logo of the \textit{Tasks.org} Free and Open Source Android App, which may be found \href{https://github.com/tasks/tasks/tree/main/graphics}{here}.

  \pagebreak
  \printbibliography
  \printnoidxglossary[type=acronym]

  \appendix
  \includepdf[pages=7-29]{../build/docs/latex/melon.pdf}
\end{document}
