\documentclass{prettytex/ox/mmsc-special-topic}
\input{customisations.tex}
\addbibresource{sources.bib}
\tikzexternalize[prefix=tikz/]

\newcommand{\topictitle}{
  Melon - a Task Scheduling Package for Todo List Applications \\
  \normalsize using Markov Chain Monte-Carlo Methods
}
\newcommand{\candidatenumber}{1072462}
\newcommand{\course}{Python in Scientific Computing}

\title{\topictitle}
\author{Candidate \candidatenumber}
\date{\today}

\makenoidxglossaries
\newacronym{mcmc}{MCMC}{Markov chain Monte-Carlo}
\newacronym{gui}{GUI}{Graphical User Interface}
\newacronym{caldav}{CalDAV}{Calendaring Extensions to WebDAV}
\newacronym{webdav}{WebDAV}{Web Distributed Authoring and Versioning}
\newacronym{ci}{CI}{Continuous Integration}
\newacronym{cd}{CD}{Continuous Delivery}
\newacronym{toml}{TOML}{Tom's Obvious, Minimal Language}

\begin{document}
  \pagestyle{plain}
  \mmscSpecialHeader

  \begin{abstract}
    \label{abstract}
    % In this project report we will review the central concepts utilised in the group work conducted to make progress in the \gls{pde} problem associated with the electrochemical model of a battery cell and present numerical results.
    \vspace*{0.2cm}

    % \noindent
    % \textbf{Our Goal:}
    % Numerically obtain the solution $\{a(x, T), b(x, T)\}$.

    The algorithm is implemented four times, twice in Python, once in Rust and also in C++.
    Python module bindings to these low-level language implementations are provided using \texttt{rust-cpython} and \texttt{pybind11}, respectively.
  \end{abstract}

  \begin{figure}[H]
    \centering
    \includegraphics[width=0.85\linewidth]{figures/melon-ui.png}
    \caption{The \gls{gui} accompanying the scheduler.}
    \label{fig:gui}
  \end{figure}

  \pagebreak
  \pagestyle{normal}

  % \tableofcontents

  \section{Problem Introduction}
  \label{sec:introduction}

  This report is concerned with finding a good scheduling approach for a given set of tasks (todos) with duration, priority, location and due date.
  The software attached with this report, going by the name of \textit{Melon}, consists of two parts: the \texttt{melon} task scheduling package itself and the Graphical User Interface written using the Qt6 framework, contained in \texttt{melongui}.
  Both of these are published as a package \textbf{melon-scheduler}, available \href{https://pypi.org/project/melon-scheduler/}{on PyPi}. It may be installed using

  \bashblock{pip install melon-scheduler}
  for just the scheduler, without the \gls{gui},

  \bashblock{pip install melon-scheduler[gui]} with the \gls{gui} or optionally,

  \bashblock{pip install melon-scheduler[gui,plots,numba]} with all extras.

  The package is capable of downloading and synchronising tasks from a calendar server supporting the industry-standard CalDAV protocol, displaying and editing them in the \gls{gui} and finally scheduling them into a calendar (cf. \Cref{fig:calendar}).
  The scheduling mechanism we implemented is a \gls{mcmc} method.

  \begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{figures/exported-calendar.png}
    \caption{The scheduled tasks, as displayed in \textit{Gnome Calendar} (the default duration for each task is one hour). Theoretically existent events could be taken into account for task scheduling as well, just as well as breaks.}
    \label{fig:calendar}
  \end{figure}

  \subsection{Idea of the Algorithm}
  We work with the following assumption on the state: the entire scheduling, given the set of tasks, is solely determined by the order in which the tasks are scheduled.
  That is, for a given order of tasks, the full schedule can be created using the supplied input data.
  With this assumption, finding the absolute optimum is tedious, especially for a large number of tasks $N \gg 1$, as there are $N!$ possible ways to order the tasks.

  The idea of the Monte Carlo method implemented here is to minimise a penalty function (borrowing the term \textit{energy} from physics) over the discrete state space of size $\mathcal{O}(N!)$ using a stochastic approach, as sketched in \Cref{sec:theory}.
  The four key properties we aim to optimise for are:
  \begin{itemize}
    \tightlist
    \item spending a minimal amount of time to complete all tasks,
    \item scheduling high priority tasks first,
    \item a low number of commutes between locations and
    \item having all tasks completed on time.
  \end{itemize}
  Due to this choice of state representation, the problem broadly mimics a Traveling Salesman Problem.

  \section{Primer on the Underlying Theory}
  \label{sec:theory}
  \begin{algorithm}[language=pseudo,caption={\centering The Metropolis-Hastings sub-routine \parencite{metropolis, hastings}},basicstyle=\footnotesize]
for $N^2$ many times, repeat
  sample a candidate $\vec{x}^*$.
  set $\vec{x}^{n+1} = \vec{x}^*$ with acceptance probability
    $p_{\rm accept} = \min\left(1, \e^{-\beta (F^{n+1} - F^n)}\right)\,,$ with $\beta \in \R^+$ a transition factor.
  Otherwise, let $\vec{x}^{n+1} = \vec{x}^{n}$.
  \end{algorithm}

  Which is a subroutine to an outer iteration, a technique commonly referred to as Simulated Annealing.

  \begin{algorithm}[language=pseudo,caption={\centering Simulated Annealing},basicstyle=\footnotesize]
let k = 1
until convergence, repeat
  set the temperature $T = T_0 k^{q}$.
  perform a sweep()
  evaluate $\langle E\rangle$ and $\left\langle\Delta E^2\right\rangle$.
  set k = k + 1
  \end{algorithm}

  During the simulation, for each temperature $T$ we evaluate the average of the energy
  $$\langle E\rangle \simeq \frac{1}{n} \sum_{\vec{x}} E(\vec{x}), \quad \text { and } \quad\left\langle E^2\right\rangle \simeq \frac{1}{n} \sum_{\vec{x}} E^2(\vec{x})$$
  and hence the variance is given by
  $$\left\langle\Delta E^2\right\rangle:=\left\langle E^2\right\rangle-\langle E\rangle^2 \,.$$

  When the variance subceeds a certain threshold, one could stop the iteration.

  \section{Package Design and Architecture}
  The \glsname{caldav} format, short for the Calendaring Extensions to \gls{webdav} \parencite{caldav-rfc} defines three types of entities: VEVENTs, VTODOs and VJOURNALs.
  These entities are organised into calendars, for our purposes these could be thought of as different todo lists.
  \textit{Melon} interacts with CalDAV servers and objects through Python's \texttt{caldav} package.
  A decent amount of the code in \texttt{melon} and \texttt{melongui} is concerned with the interaction from the package to these objects.
  Within the scope of this report, we will focus on a smaller version of these VTODO objects, created for a swift interface to the scheduler algorithm implementations.

  This small object version, containing data relevant to the scheduling mechanism, looks like this:
  \begin{minted}{python}
    import dataclasses
    from datetime import datetime

    @dataclasses.dataclass
    class Task:
        uid: str  # unique identifier of the task
        duration: float  # estimated, in hours
        priority: int  # between 1 and 9
        location: int  # number indicating the location, 0 is "hybrid"
        due: datetime | None  # when the task is due
  \end{minted}

  UIDs are useful because they make collisions very unlikely, which is not to say that these should not be checked, but if two clients are connected that each generated a set of UIDs it is very unlikely to have to do conflict resolving.

  Is platform-independent, for example due to the usage of \texttt{pathlib.Path}.

  \section{Installation and Usage}
  \subsection{Package Usage}
  After running \bash{pip install melon-scheduler[gui]} and starting a Python console, the following code snippet should start the \gls{gui}:

  \begin{minted}{python}
    from melongui.main import main
    main()  # to start the GUI
  \end{minted}

  \begin{minted}{python}
    from melon.melon import Melon
    from melon.scheduler.rust import RustyMCMCScheduler

    melon = Melon()
    melon.autoInit()
    melon.scheduleAllAndExport(path, Scheduler=RustyMCMCScheduler)
  \end{minted}

  \begin{minted}{python}
    from melon.scheduler.rust import RustyMCMCScheduler

    tasks = generateManyDemoTasks(N=80)
    scheduler = RustyMCMCScheduler(tasks)
    result = scheduler.schedule()
  \end{minted}

  If not specified in the initialiser, Melon loads a configuration file located in the user's home configuration directory, so on Linux \texttt{~/.config/melon/config.toml}.
  The file uses \gls{toml} format and has the following contents:
  \begin{minted}{toml}
[client]
url = "https://my-caldav-server.org:2023/dav/user/calendars/"
username = "user"
password = "password"
  \end{minted}

  \subsection{Full Project Usage}
  The ZIP file contains a number of configuration files at the top level, the two main code folders \texttt{melon} and \texttt{melongui}, \texttt{tests}, \texttt{docs} and the \texttt{report}.
  There are two main entrypoints to running the code: \texttt{main.py} to run the GUI, as well as \texttt{tasks.py} which contains miscellanous development and analysis scripts which are all callable by calling \bash{invoke (name-of-the-task) (arguments) (----keyword-arguments)}.

  % TODO: describe installation, etc., running main.py
  Use \texttt{invoke -l} to list all available tasks.

  \texttt{conan install . ----output-folder=build ----build=missing}

  We recommend usage with \texttt{xandikos}, a version-controlled DAV server, capable of syncing calendars (events, todos and journals) and contacts.
  Following the standard protocol, \textit{Melon} is also compatible with commercial services such Google Calendar or Microsoft Office, as long as these offer an API endpoint with suitable authentication.

  \section{Code Quality}
  \subsection{Formatting}
  \subsection{Docstrings}
  \subsection{Documentation}
  \subsection{Tests}
  Server can be started using Docker.

  As we can see using \texttt{pytest ----durations=0},

  \texttt{
    ========================= slowest durations ========================= \\
    3.53s call TestScheduler::test\_length[NumbaMCMCScheduler] \\
    0.19s call TestMelon::test\_init\_store\_and\_load \\
    (...)
  }

  the slowest test is the first routine involving the Numba scheduler which takes some time to pre-compile the functions.
  So even when the runtime of the Numba scheduler itself is low (cf. \cref{sec:runtime}), the test will always take some extra time.

  \subsubsection{Coverage}
  \begin{table}[H]
    \centering
    \caption{Test coverage of the \texttt{melon} package: platform linux, python 3.11.4-final-0. This table may be reproduced using \bash{pytest --cov=melon}.}
    \begin{tabular}{lrrr}
      \hline
      \bf Name                        & \bf Statements & \bf Miss & \bf Cover                    \\
      \hline
      melon/\_\_init\_\_.py           & 0              & 0        & \textcolor{green}{100 \%}    \\
      melon/calendar.py               & 57             & 5        & \textcolor{green}{91 \%}     \\
      melon/config.py                 & 12             & 0        & \textcolor{green}{100 \%}    \\
      melon/melon.py                  & 121            & 8        & \textcolor{green}{93 \%}     \\
      melon/scheduler/\_\_init\_\_.py & 0              & 0        & \textcolor{green}{100 \%}    \\
      melon/scheduler/base.py         & 40             & 3        & \textcolor{green}{92 \%}     \\
      melon/scheduler/cpp.py          & 18             & 5        & \textcolor{green}{72 \%}     \\
      melon/scheduler/purepython.py   & 83             & 0        & \textcolor{green}{100 \%}    \\
      melon/scheduler/rust.py         & 18             & 5        & \textcolor{green}{72 \%}     \\
      melon/todo.py                   & 101            & 17       & \textcolor{green}{83 \%}     \\
      melon/visualise.py              & 42             & 2        & \textcolor{green}{95 \%}     \\
      \hline
      \bf TOTAL                       & \bf 492        & \bf 45   & \bf \textcolor{green}{91 \%}
    \end{tabular}
  \end{table}

  \subsection{Type Checking}
  Using \texttt{pyright} instead of \texttt{mypy} as it is much faster.
  \subsection{Using Appropriate Language Features}
  Using \texttt{autoflake} and \texttt{pyupgrade}.
  Used \texttt{logging}.
  \subsection{Maintaining Code Quality}
  Using \texttt{pre-commit} and GitHub Actions \gls{ci} / \gls{cd}, or simply CI/CD.

  \subsection{Publishing to PyPi}
  Published \href{https://pypi.org/project/melon-scheduler/}{here}.

  Although we believe it would have been possible to compile the C++ and Rust implementations on a CI service using a ``platform matrix'', the published package only contains compilation targets for the x86\_64 platform and Python 3.11.

  \texttt{
    \hspace*{-1em} prettier........................................................\textcolor{green}{Passed} \\
    fix end of files................................................\textcolor{green}{Passed} \\
    trim trailing whitespace........................................\textcolor{green}{Passed} \\
    black...........................................................\textcolor{green}{Passed} \\
    ruff............................................................\textcolor{green}{Passed} \\
    check blanket noqa..............................................\textcolor{green}{Passed} \\
    check for eval()................................................\textcolor{green}{Passed} \\
    interrogate.....................................................\textcolor{green}{Passed} \\
    autoflake.......................................................\textcolor{green}{Passed} \\
    pyupgrade.......................................................\textcolor{green}{Passed} \\
    pyright.........................................................\textcolor{green}{Passed} \\
    pytest-check....................................................\textcolor{green}{Passed} \\
    clang-format....................................................\textcolor{green}{Passed} \\
    latex-format-all................................................\textcolor{green}{Passed}
  }

  Uses \texttt{invoke} to manage common development tasks. Running \bash{inv -l} yields the following selection of tasks:

  \begin{table}[H]
    \centering
    \caption{Invoke Tasks}
    \begin{tblr}{colspec={X[5cm] X[\linewidth - 6cm]}}
      \texttt{build-docs}              & {Builds documentation using Sphinx.} \\
      \texttt{compare-runtime}         & {Compares runtime of the different scheduling implementations.} \\
      \texttt{compile}                 & {Assuming a full setup, compiles the low-level implementations of the scheduler algorithm in C++ and Rust.}\\
      \texttt{ipython-shell}           & {Starts an IPython shell with Melon initialised.} \\
      \texttt{plot-convergence}        & {Plots scheduler convergence to a file.} \\
      \texttt{plot-runtime-complexity} & {Simulates with a varying number of tasks and plots runtime complexity.} \\
      \texttt{profile-scheduler}       & {Profile the pure Python MCMC Scheduler.} \\
      \texttt{schedule-and-export}     & {Run the MCMC scheduler and export the resulting events as an ICS file.} \\
      \texttt{start-mock-server}       & {Starts a Xandikos (CalDAV) server on port 8000.}
    \end{tblr}
  \end{table}

  Also have \texttt{nitpick} to synchronise linter configuration across projects.

  \begin{minted}{python}
    import numpy
    x = 5
    print(x ** 2)
  \end{minted}

  interrogate -v einfügen

  \begin{table}[H]
    \centering
    \caption{Result: \textcolor{green}{\bf Passed} (minimum: 80.0\%, actual: 100.0\%)}
    \begin{tabular}{lllll}
      \hline
      \bf Name                        & \bf Total & \bf Miss & \bf Cover & \bf Cover                 \\
      \hline
      main.py                         & 2         & 0        & 2         & \textcolor{green}{100 \%} \\
      tasks.py                        & 8         & 0        & 8         & \textcolor{green}{100 \%} \\
      docs/conf.py                    & 1         & 0        & 1         & \textcolor{green}{100 \%} \\
      melon/\_\_init\_\_.py           & 1         & 0        & 1         & \textcolor{green}{100 \%} \\
      melon/calendar.py               & 11        & 0        & 11        & \textcolor{green}{100 \%} \\
      melon/config.py                 & 1         & 0        & 1         & \textcolor{green}{100 \%} \\
      melon/melon.py                  & 19        & 0        & 19        & \textcolor{green}{100 \%} \\
      melon/todo.py                   & 20        & 0        & 20        & \textcolor{green}{100 \%} \\
      melon/visualise.py              & 3         & 0        & 3         & \textcolor{green}{100 \%} \\
      melon/scheduler/\_\_init\_\_.py & 1         & 0        & 1         & \textcolor{green}{100 \%} \\
      melon/scheduler/base.py         & 10        & 0        & 10        & \textcolor{green}{100 \%} \\
      melon/scheduler/cpp.py          & 3         & 0        & 3         & \textcolor{green}{100 \%} \\
      melon/scheduler/numba.py        & 8         & 0        & 8         & \textcolor{green}{100 \%} \\
      melon/scheduler/purepython.py   & 12        & 0        & 12        & \textcolor{green}{100 \%} \\
      melon/scheduler/rust.py         & 3         & 0        & 3         & \textcolor{green}{100 \%} \\
      melongui/\_\_init\_\_.py        & 1         & 0        & 1         & \textcolor{green}{100 \%} \\
      melongui/calendarlist.py        & 6         & 0        & 6         & \textcolor{green}{100 \%} \\
      melongui/mainwindow.py          & 14        & 0        & 14        & \textcolor{green}{100 \%} \\
      melongui/taskitemdelegate.py    & 12        & 0        & 12        & \textcolor{green}{100 \%} \\
      melongui/tasklist.py            & 14        & 0        & 14        & \textcolor{green}{100 \%} \\
      melongui/taskwidgets.py         & 8         & 0        & 8         & \textcolor{green}{100 \%} \\
      tests/\_\_init\_\_.py           & 1         & 0        & 1         & \textcolor{green}{100 \%} \\
      tests/test\_melon.py            & 7         & 0        & 7         & \textcolor{green}{100 \%} \\
      tests/test\_scheduler.py        & 9         & 0        & 9         & \textcolor{green}{100 \%} \\
      \hline
      \bf TOTAL                       & 175       & 0        & 175       & \textcolor{green}{100 \%} \\
      \hline
    \end{tabular}
  \end{table}

  Screenshot von gnome-calendar

  Screenshot GUI

  \subsection{Autocorrelation Analysis}
  \subsection{Coole Pie-Plots mit Verteilungen}

  \section{Runtime Performance}
  \label{sec:runtime}
  The following benchmarks were all accumulated on an x86\_64 Intel\textregistered \, i7-5600U CPU running at \SI{2.6}{\giga\hertz} verified through 3 individual runs, keeping parameters consistent along them.

  \begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{results/complexity.pdf}
    \caption{Complexity plot}
  \end{figure}

  \begin{minted}{python}
In [1]: %timeit str(t.icalendar_component["uid"])
  122 µs ± 1.06 µs per loop (7 runs, 10,000 loops each)
In [2]: %timeit t.vtodo.contents["uid"][0].value
  355 ns ± 7.14 ns per loop (7 runs, 1,000,000 loops each)
In [3]: %timeit t.vobject_instance.contents["vtodo"][0].contents["uid"][0].value
  296 ns ± 7.06 ns per loop (7 runs, 1,000,000 loops each)
In [4]: %timeit t._vobject_instance.contents["vtodo"][0].contents["uid"][0].value
  208 ns ± 23.7 ns per loop (7 runs, 10,000,000 loops each)
  \end{minted}

  \begin{table}[H]
    \centering
    \caption{Profile obtained by running \mintinline{bash}{./main.py --profile & grep todo.py}.}
    \begin{tabular}{rrrrrll}
      \hline
      ncalls & tottime & percall & cumtime & percall & filename:lineno & function     \\
      \hline
      16958  & 0.008   & 0.000   & 0.939   & 0.000   & todo.py:36      & vtodo        \\
      32475  & 0.047   & 0.000   & 0.705   & 0.000   & todo.py:96      & uid          \\
      856    & 0.003   & 0.000   & 0.579   & 0.001   & todo.py:26      & upgrade      \\
      117    & 0.000   & 0.000   & 0.489   & 0.004   & todo.py:111     & priority     \\
      417    & 0.001   & 0.000   & 0.461   & 0.001   & todo.py:121     & isIncomplete \\
      5512   & 0.003   & 0.000   & 0.278   & 0.000   & todo.py:45      & summary      \\
      856    & 0.002   & 0.000   & 0.112   & 0.000   & todo.py:21      & \_\_init\_\_ \\
      1363   & 0.006   & 0.000   & 0.024   & 0.000   & todo.py:164     & \_\_lt\_\_   \\
      7844   & 0.004   & 0.000   & 0.009   & 0.000   & todo.py:61      & dueDate      \\
      2605   & 0.001   & 0.000   & 0.003   & 0.000   & todo.py:85      & dueTime      \\
    \end{tabular}
  \end{table}

  \begin{table}[H]
    \centering
    \caption{Profile obtained by running \mintinline{bash}{inv profile-scheduler & grep purepython.py}.}
    \begin{tabular}{rrrrrll}
      \hline
      \bf Ncalls & \bf Total & \bf / call & \bf Cum. & \bf / call & \bf Filename:line & \bf Function     \\
      \hline
      1          & 0.000     & 0.000      & 14.236   & 14.236     & purepython:142    & schedule         \\
      10         & 0.209     & 0.021      & 14.235   & 1.424      & purepython:123    & mcmcSweep        \\
      36010      & 1.144     & 0.000      & 13.784   & 0.000      & purepython:97     & computeEnergy    \\
      2196671    & 5.391     & 0.000      & 11.353   & 0.000      & purepython:41     & spreadTasks      \\
      1006332    & 1.389     & 0.000      & 1.842    & 0.000      & purepython:27     & generateNextSlot \\
      2196610    & 0.798     & 0.000      & 0.972    & 0.000      & purepython:108    & <genexpr>        \\
      2196610    & 0.384     & 0.000      & 0.384    & 0.000      & purepython:106    & <genexpr>        \\
      36000      & 0.082     & 0.000      & 0.217    & 0.000      & purepython:83     & permuteState     \\
      36011      & 0.046     & 0.000      & 0.124    & 0.000      & purepython:19     & startingSlot     \\
    \end{tabular}
  \end{table}

  \section{Results}
  \begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{results/convergence-8h-day.pdf}
    \caption{Temperature, average energy and energy variance for an 8-hour work day. Low variance can be used as a stopping criterion (cf. \Cref{sec:theory}).}
  \end{figure}
  \begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{results/convergence-14h-day.pdf}
    \caption{Temperature, average energy and energy variance for a 14-hour work day.}
  \end{figure}

  Numba Compilation time: 3.212771240971051

  \begin{table}[H]
    \vspace{0.5cm}
    \centering
    \caption{Runtime Comparison of the different implementations run on the same scenarios. Each runtime is given as the average over three runs. The finite difference schemes (for the one-dimensional case) were run with $N_x = N_t = 4000$ up to $T = 40$. The spectral method was run using a series expansion of order 15, also up to $T = 40$. The remaining parameters ($\alpha$, $\kappa_0$, $E_0$, etc.) were all identical.}
    \begin{tblr}{
      colspec={llr},
      row{2,3} = {bg=azure9},
          row{4} = {bg=violet9},
          row{5} = {bg=cyan9},
        }
      \hline
      \bf Implementation & \bf Language & \bf Runtime / seconds \\
      \hline
      MCMCScheduler      & Python & 31.3887 \\
      NumbaMCMCScheduler & Python & 1.9335 \\
      \hline
      RustyMCMCScheduler & Rust & 0.4034 \\
      \hline
      CppMCMCScheduler   & C++ & 0.4062
      \hline
    \end{tblr}
    \label{table:runtime}
  \end{table}

  \section{Acknowledgements}
  The visualisation code (\texttt{visualise.py}) is adapted from \cite{monte-carlo-todo-lists}.

  The task check icon is the logo of the \textit{Tasks.org} Free and Open Source Android App, which may be found \href{https://github.com/tasks/tasks/tree/main/graphics}{here}.

  \pagebreak
  \printbibliography
  \printnoidxglossary[type=acronym]

  \appendix
  \includepdf[pages=7-29]{../build/docs/latex/melon.pdf}
\end{document}
